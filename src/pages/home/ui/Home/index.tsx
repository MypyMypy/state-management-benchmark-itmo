import React from 'react';
import styles from './Home.module.css';

export const Home: React.FC = () => (
  <div className={styles.root}>
    <h1>Эксперимент: Управление состоянием (Redux Toolkit vs MobX vs Effector)</h1>
    <p>
      Цель: сопоставить накладные расходы разных подходов к управлению состоянием в трёх типовых
      ситуациях: массив карточек с периодическими обновлениями (каталог), интерактивная форма с
      валидацией и поток случайных значений высокой частоты (стрим). Все сценарии визуализируются
      одинаковыми компонентами карточек для утяжеления рендеринга и большей дифференциации.
    </p>

    <h2>S1: Каталог (карточки, инкрементальные апдейты)</h2>
    <p>
      Большой список элементов (по умолчанию 10 000). Каждая карточка имеет вычислённые производные
      значения и небольшой локальный спарклайн. Панель управления позволяет: фильтровать по имени,
      сортировать по значению, запускать/останавливать фоновую волну обновлений (20 случайных изменений
      в секунду), добавлять пачку новых элементов, удалять случайных, удалять выбранные (через чекбоксы).
    </p>
    <ul>
      <li>Redux метка: <code>redux:updates</code></li>
      <li>MobX метка: <code>mobx:updates</code></li>
      <li>Effector метка: <code>effector:updates</code></li>
      <li>Цель измерения: время применения набора обновлений и последующих перерендеров.</li>
    </ul>
    <p>
      <strong>Воспроизведение:</strong> откройте соответствующую страницу (Redux / MobX / Effector), нажмите
      <em>Запустить обновления</em>, дайте прогреться 20–30 секунд, затем наблюдайте показатели в панели Perf.
      Меняйте размер выборки (Add), удаляйте элементы, фиксируйте стабильный период (60–120 секунд) и экспортируйте JSON.
    </p>

    <h2>S2: Форма (валидация / локальные и глобальные проверки)</h2>
    <p>
      Набор полей с синхронной и отложенной (debounce) валидацией, агрегацией состояния и глобальной
      сводкой валидности. Цель — измерить
      накладные расходы реакций на ввод и распространения статуса валидности.
    </p>
    <p>
      <strong>Воспроизведение:</strong> быстро вводите значения в поля, переключайтесь между ними, имитируйте
      массовый ввод (можно вставить текст). Отмечайте в PerfPanel измерения рендеров (по именам scenario‑специфичных меток) и Web Vitals при начальной загрузке.
    </p>

    <h2>S3: Поток (реал-тайм обновления карточек)</h2>
    <p>
      Массив из 1000 значений с непрерывными пакетными обновлениями. Каждая карточка хранит историю последних значений,
      считает число перерисовок (badge) и подсвечивается при изменении. Управление: скорость обновлений (Скорость) и число видимых карточек (Видимых карточек).
    </p>
    <ul>
      <li>Redux метка: <code>redux:stream</code></li>
      <li>MobX метка: <code>mobx:stream</code></li>
      <li>Effector метка: <code>effector:stream</code></li>
      <li>Цель измерения: устойчивость при высокочастотных обновлениях и масштабирование видимых элементов.</li>
    </ul>
    <p>
      <strong>Воспроизведение:</strong> уменьшайте / увеличивайте скорость и количество видимых карточек. Наблюдайте изменение распределения длительностей мерок.
    </p>

    <h2>PerfPanel и метрики</h2>
    <p>
      В правом нижнем углу встроена панель Perf: если не нужна в production — добавьте <code>?perf=off</code> к URL.
      Панель показывает агрегаты для <code>performance.measure()</code>: <em>Количество</em>, <em>Среднее</em>, <em>p50</em>, <em>p95</em>, <em>p99</em>, <em>Мин</em>, <em>Макс</em>, а также спарклайн последних 30 замеров.
      Web Vitals (LCP, CLS, INP, TTFB) пополняются по мере событий. Кнопки: Обновить, Очистить (сброс всех меток), Экспорт (JSON с сырыми measure + vitals).
    </p>

    <h2>Рекомендуемая методика оценки</h2>
    <ol>
      <li><strong>Выравнивание параметров:</strong> выберите одинаковые значения (число карточек, частота обновлений, видимые карточки).</li>
      <li><strong>Прогрев:</strong> проигнорируйте первые 20–30 сек (формирование кешей, JIT, GC прогрев).</li>
      <li><strong>Сбор данных:</strong> фиксируйте окно 60–120 сек стабильной нагрузки. Не меняйте параметры в середине окна.</li>
      <li><strong>Экспорт:</strong> нажмите Export и сохраните JSON для каждого фреймворка.</li>
      <li><strong>Анализ:</strong> сравните p95/p99 (хвост распределения), p50 (медиана), Mean (средняя). Большее Count при равной конфигурации может указывать на более мелкие быстрые апдейты или частичный оверхед.</li>
      <li><strong>Аномалии:</strong> изучите Max: резкие пики могут быть связаны с GC или рекомпиляцией. При необходимости повторите несколько прогонов.</li>
      <li><strong>Интерпретация:</strong> предпочтительны меньшие p95/p99 при приемлемой медиане. Снижение хвоста важнее минимального Mean.</li>
    </ol>

    <h2>Практические советы</h2>
    <ul>
      <li>Запускайте финальные сравнения в production сборке: <code>npm run build &amp;&amp; npm run preview</code>.</li>
      <li>Закройте тяжёлые вкладки / DevTools профайлер на время чистых замеров (он добавляет накладные расходы).</li>
      <li>Держите стабильную частоту CPU (избегайте энергосбережения ноутбука).</li>
      <li>Сравнивайте только после того как все фреймворки прогреты аналогичным образом.</li>
      <li>Используйте Clear перед новым прогоном, чтобы не смешивать распределения.</li>
    </ul>

    <h2>Интерпретация метрик панели</h2>
    <ul>
      <li><strong>Mean:</strong> усреднённая длительность операции.</li>
      <li><strong>p50:</strong> медиана — половина операций быстрее этого порога.</li>
      <li><strong>p95 / p99:</strong> верхние хвосты — реакция на нагрузку в "стресс" моменты.</li>
      <li><strong>Min / Max:</strong> полезны для обнаружения экстремальных выбросов.</li>
      <li><strong>Last 30:</strong> динамика — помогает увидеть дрейф производительности.</li>
    </ul>

    <h2>Почему несколько фреймворков</h2>
    <p>
      Разные модели реактивности (императивные редюсеры, прозрачная реактивность, граф событий) ведут к отличиям
      в распределении времени обновления и числу затронутых компонентов. Сценарии подобраны так, чтобы проявить
      стоимость диффузии изменений (S1), локально-глобальных зависимостей (S2) и высокочастотных потоков (S3).
    </p>
  </div>
);
